import subprocess
import json
import socket
import re
import netaddr

class Hemicarp:
  """
  Admin API accessible with tcp or unix socket
    - admin_endpoint=("127.0.0.2", 3959)
    - admin_endpoint="/pirates/microprovision/remote-ygg.sock"
  """

  def __init__(self, name=None, admin_endpoint='/var/run/yggdrasil.sock'):
    self.name = name
    self.admin_endpoint = admin_endpoint
    self.list = self.yggCaller(json.dumps({"request":"list"}))
    self.nodeinfo = self.yggCaller(json.dumps({"request":"getself"}))['response']['self']
    self.ipv6 = list(self.nodeinfo.keys())[0]
    self.build_version = self.nodeinfo[self.ipv6]['build_version']
    self.box_pub_key = self.nodeinfo[self.ipv6]['box_pub_key']
    self.coords = self.nodeinfo[self.ipv6]['coords']
    self.subnet = self.nodeinfo[self.ipv6]['subnet']
  # /init

  def allowSource(self, subnet):
    return self.yggCaller(json.dumps({"request":"addlocalsubnet", "subnet": subnet}))

  def addRoute(self, subnet, pubkey):
    return self.yggCaller(json.dumps({"request":"addremotesubnet", "subnet": subnet, "box_pub_key": pubkey}))

  def addPeer(self, uri):
    return self.yggCaller(json.dumps({"request":"addpeer", "uri": uri}))

  def getPeers(self):
    return self.yggCaller(json.dumps({"request":"getpeers"}))['response']['peers']

  def enableTunnel(self):
    return self.yggCaller(json.dumps({"request":"settunnelrouting", "enabled": True}))['response']['enabled']

  def disableTunnel(self):
    return self.yggCaller(json.dumps({"request":"settunnelrouting", "enabled": False}))['response']['enabled']


  def yggCaller(self, pqrs):
    try:
      if (type(self.admin_endpoint) == str):
        s = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
      elif (type(self.admin_endpoint) == tuple):
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
      else:
        print ('unknown yggdrasil endpoint type', type(self.admin_endpoint))
      s.connect(self.admin_endpoint)
      s.send(pqrs.encode('utf-8'))
      f = s.makefile('r')

    except PermissionError as e:
      print('error:: Permission Error AF_UNIX: ' + self.admin_endpoint)
      print('        Try: chown root:$(whoami) ' + self.admin_endpoint)
      exit()


    while True:
      data = f.read();
      if (data == ""):
        break
      else:
        try:
          gatos += data
        except NameError as e:
          gatos = data

    s.close()

    try:
      return json.loads(gatos)
    except:
      return {"status": "error"}
  #<!-- end caller-->


def client_provision():
    gateway_pub_key = subprocess.run(["uci", "get", "system.gateway.key"], capture_output=True)
    client_ip = subprocess.run(["uci", "get", "system.gateway.cl_ip"], capture_output=True)
    gateway_ip = subprocess.run(["uci", "get", "system.gateway.gw_ip"], capture_output=True)
    wan_gw = subprocess.run("ubus call network.interface.wan status | jq .route[0].nexthop", shell=True, capture_output=True)

    if (gateway_pub_key.returncode == 0 and gateway_pub_key.stdout.strip()
       and client_ip.returncode == 0 and client_ip.stdout.strip()
       and gateway_ip.returncode == 0 and gateway_ip.stdout.strip()
       and wan_gw.returncode == 0 and wan_gw.stdout.strip()):
        addip(client_ip.stdout.strip(), "ygg0") # Add gateway_ip to ygg iface
        addremotesubnet("0.0.0.0/0", gateway_pub_key.stdout.strip().decode("utf-8")) # add remote subnet to ygg running config

        # fixme: get this list dynamically from ygg conf
        # fixme: wan_gw is null when no wan, we should not rely on this
        wan_gw = ("127.0.0.1" if wan_gw.stdout.strip().decode("utf-8") == "null" else wan_gw.stdout.strip().decode("utf-8").strip('\"'))
        addroute("50.236.201.218", wan_gw) # for each peer, add bypass route
        addroute("45.76.166.128", wan_gw) # for each peer, add bypass route
        addroute("45.77.107.150", wan_gw) # for each peer, add bypass route
        addroute("108.175.10.127", wan_gw) # for each peer, add bypass route
        addroute("198.58.100.240", wan_gw) # for each peer, add bypass route
        setdefaultroute(gateway_ip.stdout.strip()) # set default route to gateway_ip
    else:
        print("some error in client_provision")


def bpk_to_ipaddr(box_pub_key=False):
    try:
        assert(box_pub_key)
        assert(re.match('(^[a-z0-9]{64}$)', box_pub_key)[0])

        bpk_lookup = subprocess.check_output([ 'yggdrasil', "-address", "-useconf"],
                        input=bytes(json.dumps({'EncryptionPublicKey': box_pub_key}), 'utf-8'))
        bpk_lookup = bpk_lookup.decode('utf-8').replace("\n", "")
        assert(netaddr.IPAddress(bpk_lookup))

        return bpk_lookup
    except:
        return None

def gateway_provision():
    print("fixme: gateway_provision")
    # util.addip() # add gateway ip to ygg interface if not already set

def addroute(dest, gateway):
    subprocess.run(["ip", "ro", "repl", dest, "via", gateway])

def setdefaultroute(gateway):
    subprocess.run(["ip", "ro", "repl", "default", "via", gateway])

def addip(ip, iface):
    subprocess.run(["ip", "addr", "repl", ip, "dev", iface])

def addremotesubnet(subnet, pubkey):
    # fixme: this will error but shouldn't break when run repeatedly. Add a check for the subnet before trying to add it
    subprocess.run(["yggdrasilctl", "removeremotesubnet", "subnet=" + subnet, "box_pub_key=" + pubkey])
    subprocess.run(["yggdrasilctl", "addremotesubnet", "subnet=" + subnet, "box_pub_key=" + pubkey])
